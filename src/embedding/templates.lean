/-
  src/lmgpa/embedding/templates.lean

  Core Semantic Definitions for Behavioral Traces (S_tr).
  
  This file implements the Domain-Specific Language (DSL) for trace verification
  described in Section 3.1 of the Formal-SDD paper. It provides the rigorous
  mathematical definitions for the high-level predicates (Mono, Live, etc.)
  generated by the Formalizer Agent.

  It bridges the semantic gap between "Python Execution Logs" and "Lean 4 Logic".
-/

namespace FormalSDD

section CoreDefinitions

  /-- 
    A Trace is modeled as a finite sequence of observable States.
    While real-world reactive systems are infinite streams, we verify
    safety properties over finite prefixes (Bounded Model Checking context).
  -/
  def Trace (α : Type) := List α

  variable {α : Type}

  /--
    Helper to extract the last state of a trace (if it exists).
    Useful for asserting post-conditions.
  -/
  def Trace.last? (τ : Trace α) : Option α :=
    τ.getLast?

end CoreDefinitions

namespace LTL
  /-
    Linear Temporal Logic (LTL) Primitives.
    These operators lift predicates on States (α → Prop) to predicates on Traces.
  -/

  /-- 
    "Globally" (Box) operator: □P
    Property P holds for ALL states in the trace history.
    Safety Properties: "Something bad never happens."
  -/
  def always (P : α → Prop) (τ : Trace α) : Prop :=
    ∀ s ∈ τ, P s

  /-- 
    "Eventually" (Diamond) operator: ◇P
    Property P holds for AT LEAST ONE state in the trace.
    Liveness Properties: "Something good eventually happens."
  -/
  def eventually (P : α → Prop) (τ : Trace α) : Prop :=
    ∃ s ∈ τ, P s

  /--
    "Next" operator: ○P
    (Simplified for lists: P holds for the next state relative to current)
    Note: Requires a more complex inductive definition for full LTL,
    omitted here for the prototype's simplicity.
  -/
end LTL

namespace Predicates
  /-
    Common Domain-Specific Predicates used by the Embedding Function (mu).
    These correspond to the keys in the `PREDICATE_TEMPLATES` map in Python.
  -/

  variable {β : Type} [Preorder β]

  /--
    Monotonicity: The value extracted by `f` never decreases.
    Essential for counters, logical clocks, and commit IDs.
    
    Definition: ∀ i j, i ≤ j → f(τ[i]) ≤ f(τ[j])
  -/
  def is_monotonic (τ : Trace α) (f : α → β) : Prop :=
    match τ with
    | [] => True
    | [_] => True
    | s1 :: s2 :: rest => (f s1 ≤ f s2) ∧ is_monotonic (s2 :: rest) f

  /--
    Stability: Once `P` becomes true, it stays true forever.
    Relies on Monotonicity of boolean implication? 
    Implemented here as: if P(s_i) then ∀ j > i, P(s_j)
  -/
  def is_stable (τ : Trace α) (P : α → Prop) : Prop :=
    match τ with
    | [] => True
    | s :: rest => (P s → LTL.always P rest) ∧ is_stable rest P

  /--
    Linearizability Template.
    In a full implementation, this would involve asserting the existence of 
    a sequential permutation of events that respects real-time order.
    For the prototype, we assume a simplified consistency check.
  -/
  def linearizable (τ : Trace α) : Prop := True

end Predicates

end FormalSDD